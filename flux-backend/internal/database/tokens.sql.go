// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tokens.sql

package database

import (
	"context"
	"encoding/json"
	"time"
)

const createToken = `-- name: CreateToken :one
INSERT INTO tokens (hashed_token, purpose, payload, email, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, hashed_token, purpose, payload, email, expires_at, created_at
`

type CreateTokenParams struct {
	HashedToken string          `json:"hashed_token"`
	Purpose     string          `json:"purpose"`
	Payload     json.RawMessage `json:"payload"`
	Email       string          `json:"email"`
	ExpiresAt   time.Time       `json:"expires_at"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) (Token, error) {
	row := q.db.QueryRow(ctx, createToken,
		arg.HashedToken,
		arg.Purpose,
		arg.Payload,
		arg.Email,
		arg.ExpiresAt,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.HashedToken,
		&i.Purpose,
		&i.Payload,
		&i.Email,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteByEmailAndPurpose = `-- name: DeleteByEmailAndPurpose :exec
DELETE FROM tokens WHERE email = $1 AND purpose = $2
`

type DeleteByEmailAndPurposeParams struct {
	Email   string `json:"email"`
	Purpose string `json:"purpose"`
}

func (q *Queries) DeleteByEmailAndPurpose(ctx context.Context, arg DeleteByEmailAndPurposeParams) error {
	_, err := q.db.Exec(ctx, deleteByEmailAndPurpose, arg.Email, arg.Purpose)
	return err
}

const getTokenByEmailAndPurpose = `-- name: GetTokenByEmailAndPurpose :one
SELECT id, hashed_token, purpose, payload, email, expires_at, created_at
FROM tokens
WHERE email = $1 AND purpose = $2
ORDER BY created_at DESC 
LIMIT 1
`

type GetTokenByEmailAndPurposeParams struct {
	Email   string `json:"email"`
	Purpose string `json:"purpose"`
}

// helps handle duplicate tokens:
func (q *Queries) GetTokenByEmailAndPurpose(ctx context.Context, arg GetTokenByEmailAndPurposeParams) (Token, error) {
	row := q.db.QueryRow(ctx, getTokenByEmailAndPurpose, arg.Email, arg.Purpose)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.HashedToken,
		&i.Purpose,
		&i.Payload,
		&i.Email,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}
