// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: problems.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addProblem = `-- name: AddProblem :one
INSERT INTO problems (
    title,
    statement,
    input_format,
    output_format,
    example_testcases,
    notes,
    memory_limit_kb,
    time_limit_ms,
    created_by,
    last_updated_by,
    difficulty,
    submission_link,
    platform,
    lock_id
) VALUES (
    $1, -- title
    $2, -- statement
    $3, -- input_format (can be NULL)
    $4, -- output_format (can be NULL)
    $5, -- samples (can be NULL)
    $6, -- notes (can be NULL)
    $7, -- memory_limit_kb
    $8, -- time_limit_ms
    $9, -- created_by (UUID)
    $9, -- last_updated_by (UUID)
    $10, -- difficulty (can be NULL)
    $11, -- submission_link (can be NULL)
    $12, -- platform (can be NULL)
    $13 -- lock_id
)
RETURNING id, title, statement, input_format, output_format, example_testcases, notes, memory_limit_kb, time_limit_ms, created_by, last_updated_by, created_at, updated_at, difficulty, submission_link, platform, lock_id
`

type AddProblemParams struct {
	Title            string           `json:"title"`
	Statement        string           `json:"statement"`
	InputFormat      string           `json:"input_format"`
	OutputFormat     string           `json:"output_format"`
	ExampleTestcases *json.RawMessage `json:"example_testcases"`
	Notes            *string          `json:"notes"`
	MemoryLimitKb    int32            `json:"memory_limit_kb"`
	TimeLimitMs      int32            `json:"time_limit_ms"`
	CreatedBy        uuid.UUID        `json:"created_by"`
	Difficulty       int32            `json:"difficulty"`
	SubmissionLink   *string          `json:"submission_link"`
	Platform         NullPlatform     `json:"platform"`
	LockID           *uuid.UUID       `json:"lock_id"`
}

func (q *Queries) AddProblem(ctx context.Context, arg AddProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, addProblem,
		arg.Title,
		arg.Statement,
		arg.InputFormat,
		arg.OutputFormat,
		arg.ExampleTestcases,
		arg.Notes,
		arg.MemoryLimitKb,
		arg.TimeLimitMs,
		arg.CreatedBy,
		arg.Difficulty,
		arg.SubmissionLink,
		arg.Platform,
		arg.LockID,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Difficulty,
		&i.SubmissionLink,
		&i.Platform,
		&i.LockID,
	)
	return i, err
}

const checkPlatformType = `-- name: CheckPlatformType :one
SELECT $1::Platform
`

func (q *Queries) CheckPlatformType(ctx context.Context, dollar_1 Platform) (Platform, error) {
	row := q.db.QueryRow(ctx, checkPlatformType, dollar_1)
	var column_1 Platform
	err := row.Scan(&column_1)
	return column_1, err
}

const getProblemAuth = `-- name: GetProblemAuth :one
SELECT locks.id, locks.access, locks.timeout
FROM problems
LEFT JOIN locks ON problems.lock_id = locks.id
WHERE problems.id = $1
`

type GetProblemAuthRow struct {
	ID      *uuid.UUID `json:"id"`
	Access  *string    `json:"access"`
	Timeout *time.Time `json:"timeout"`
}

func (q *Queries) GetProblemAuth(ctx context.Context, id int32) (GetProblemAuthRow, error) {
	row := q.db.QueryRow(ctx, getProblemAuth, id)
	var i GetProblemAuthRow
	err := row.Scan(&i.ID, &i.Access, &i.Timeout)
	return i, err
}

const getProblemById = `-- name: GetProblemById :one
SELECT
    -- Explicitly list all columns from 'problems' except 'lock_id'
    problems.id, problems.title, problems.statement, problems.input_format, problems.output_format, problems.example_testcases, problems.notes, problems.memory_limit_kb, problems.time_limit_ms, problems.created_by, problems.last_updated_by, problems.created_at, problems.updated_at, problems.difficulty, problems.submission_link, problems.platform, problems.lock_id,

    -- Select only the 'access' column from the 'locks' table
    locks.access as lock_access,
    locks.timeout as lock_timeout
FROM
    problems
LEFT JOIN
    locks ON problems.lock_id = locks.id
WHERE
    problems.id = $1
`

type GetProblemByIdRow struct {
	ID               int32            `json:"id"`
	Title            string           `json:"title"`
	Statement        string           `json:"statement"`
	InputFormat      string           `json:"input_format"`
	OutputFormat     string           `json:"output_format"`
	ExampleTestcases *json.RawMessage `json:"example_testcases"`
	Notes            *string          `json:"notes"`
	MemoryLimitKb    int32            `json:"memory_limit_kb"`
	TimeLimitMs      int32            `json:"time_limit_ms"`
	CreatedBy        uuid.UUID        `json:"created_by"`
	LastUpdatedBy    uuid.UUID        `json:"last_updated_by"`
	CreatedAt        time.Time        `json:"created_at"`
	UpdatedAt        time.Time        `json:"updated_at"`
	Difficulty       int32            `json:"difficulty"`
	SubmissionLink   *string          `json:"submission_link"`
	Platform         NullPlatform     `json:"platform"`
	LockID           *uuid.UUID       `json:"lock_id"`
	LockAccess       *string          `json:"lock_access"`
	LockTimeout      *time.Time       `json:"lock_timeout"`
}

func (q *Queries) GetProblemById(ctx context.Context, id int32) (GetProblemByIdRow, error) {
	row := q.db.QueryRow(ctx, getProblemById, id)
	var i GetProblemByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Difficulty,
		&i.SubmissionLink,
		&i.Platform,
		&i.LockID,
		&i.LockAccess,
		&i.LockTimeout,
	)
	return i, err
}

const getProblemsByFilters = `-- name: GetProblemsByFilters :many
SELECT
    p.id,
    p.title,
    p.difficulty,
    p.platform,
    p.created_by,   
    p.created_at,
    l.id as lock_id,
    l.timeout as lock_timeout,
    l.access as lock_access
FROM
    problems AS p
LEFT JOIN
    locks AS l ON p.lock_id = l.id
WHERE
    -- Optional filter by a list of problem IDs
    -- This checks if the input slice is empty. If it is, the condition is true.
    -- If not empty, it checks if the problem ID is in the slice.
    (
        ($1::int[]) IS NULL OR
        cardinality($1::int[]) = 0 OR
        p.id = ANY($1::int[])
    )
AND
    -- Optional filter by lock_id
    (
        $2::uuid IS NULL OR
        p.lock_id = $2::uuid
    )
AND
    -- Optional filter by creator
    (
        $3::uuid IS NULL OR
        p.created_by = $3::uuid
    )
AND
    -- Title search with wildcards handled in SQL
    p.title ILIKE '%' || $4::text || '%'
ORDER BY
    p.created_at DESC
LIMIT
    $6
OFFSET
    $5
`

type GetProblemsByFiltersParams struct {
	ProblemIds  []int32    `json:"problem_ids"`
	LockID      *uuid.UUID `json:"lock_id"`
	CreatedBy   *uuid.UUID `json:"created_by"`
	TitleSearch string     `json:"title_search"`
	Offset      int32      `json:"offset"`
	Limit       int32      `json:"limit"`
}

type GetProblemsByFiltersRow struct {
	ID          int32        `json:"id"`
	Title       string       `json:"title"`
	Difficulty  int32        `json:"difficulty"`
	Platform    NullPlatform `json:"platform"`
	CreatedBy   uuid.UUID    `json:"created_by"`
	CreatedAt   time.Time    `json:"created_at"`
	LockID      *uuid.UUID   `json:"lock_id"`
	LockTimeout *time.Time   `json:"lock_timeout"`
	LockAccess  *string      `json:"lock_access"`
}

func (q *Queries) GetProblemsByFilters(ctx context.Context, arg GetProblemsByFiltersParams) ([]GetProblemsByFiltersRow, error) {
	rows, err := q.db.Query(ctx, getProblemsByFilters,
		arg.ProblemIds,
		arg.LockID,
		arg.CreatedBy,
		arg.TitleSearch,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsByFiltersRow
	for rows.Next() {
		var i GetProblemsByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Difficulty,
			&i.Platform,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.LockID,
			&i.LockTimeout,
			&i.LockAccess,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProblem = `-- name: UpdateProblem :one
UPDATE problems
SET
    title = $1,
    statement = $2,
    input_format = $3,
    output_format = $4,
    example_testcases = $5,
    notes = $6,
    memory_limit_kb = $7,
    time_limit_ms = $8,
    difficulty = $9,
    submission_link = $10,
    platform = $11,
    last_updated_by = $12,
    lock_id = $13
WHERE
    id = $14
RETURNING id, title, statement, input_format, output_format, example_testcases, notes, memory_limit_kb, time_limit_ms, created_by, last_updated_by, created_at, updated_at, difficulty, submission_link, platform, lock_id
`

type UpdateProblemParams struct {
	Title            string           `json:"title"`
	Statement        string           `json:"statement"`
	InputFormat      string           `json:"input_format"`
	OutputFormat     string           `json:"output_format"`
	ExampleTestcases *json.RawMessage `json:"example_testcases"`
	Notes            *string          `json:"notes"`
	MemoryLimitKb    int32            `json:"memory_limit_kb"`
	TimeLimitMs      int32            `json:"time_limit_ms"`
	Difficulty       int32            `json:"difficulty"`
	SubmissionLink   *string          `json:"submission_link"`
	Platform         NullPlatform     `json:"platform"`
	LastUpdatedBy    uuid.UUID        `json:"last_updated_by"`
	LockID           *uuid.UUID       `json:"lock_id"`
	ID               int32            `json:"id"`
}

func (q *Queries) UpdateProblem(ctx context.Context, arg UpdateProblemParams) (Problem, error) {
	row := q.db.QueryRow(ctx, updateProblem,
		arg.Title,
		arg.Statement,
		arg.InputFormat,
		arg.OutputFormat,
		arg.ExampleTestcases,
		arg.Notes,
		arg.MemoryLimitKb,
		arg.TimeLimitMs,
		arg.Difficulty,
		arg.SubmissionLink,
		arg.Platform,
		arg.LastUpdatedBy,
		arg.LockID,
		arg.ID,
	)
	var i Problem
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Statement,
		&i.InputFormat,
		&i.OutputFormat,
		&i.ExampleTestcases,
		&i.Notes,
		&i.MemoryLimitKb,
		&i.TimeLimitMs,
		&i.CreatedBy,
		&i.LastUpdatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Difficulty,
		&i.SubmissionLink,
		&i.Platform,
		&i.LockID,
	)
	return i, err
}
