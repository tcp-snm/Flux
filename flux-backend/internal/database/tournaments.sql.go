// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tournaments.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addTournamentContest = `-- name: AddTournamentContest :exec
INSERT INTO tournament_contests (round_id, contest_id)
VALUES ($1, $2)
`

type AddTournamentContestParams struct {
	RoundID   uuid.UUID `json:"round_id"`
	ContestID uuid.UUID `json:"contest_id"`
}

func (q *Queries) AddTournamentContest(ctx context.Context, arg AddTournamentContestParams) error {
	_, err := q.db.Exec(ctx, addTournamentContest, arg.RoundID, arg.ContestID)
	return err
}

const createTournament = `-- name: CreateTournament :one
INSERT INTO tournaments (
    title, is_published, created_by
) VALUES ($1, $2, $3)
RETURNING id, title, is_published, created_by, created_at, updated_at
`

type CreateTournamentParams struct {
	Title       string    `json:"title"`
	IsPublished bool      `json:"is_published"`
	CreatedBy   uuid.UUID `json:"created_by"`
}

func (q *Queries) CreateTournament(ctx context.Context, arg CreateTournamentParams) (Tournament, error) {
	row := q.db.QueryRow(ctx, createTournament, arg.Title, arg.IsPublished, arg.CreatedBy)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.IsPublished,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTournamentRound = `-- name: CreateTournamentRound :one
INSERT INTO tournament_rounds (
    tournament_id, round_number, title, lock_id, created_by
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, tournament_id, round_number, title, lock_id, created_by, updated_at
`

type CreateTournamentRoundParams struct {
	TournamentID uuid.UUID  `json:"tournament_id"`
	RoundNumber  int32      `json:"round_number"`
	Title        string     `json:"title"`
	LockID       *uuid.UUID `json:"lock_id"`
	CreatedBy    uuid.UUID  `json:"created_by"`
}

func (q *Queries) CreateTournamentRound(ctx context.Context, arg CreateTournamentRoundParams) (TournamentRound, error) {
	row := q.db.QueryRow(ctx, createTournamentRound,
		arg.TournamentID,
		arg.RoundNumber,
		arg.Title,
		arg.LockID,
		arg.CreatedBy,
	)
	var i TournamentRound
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.RoundNumber,
		&i.Title,
		&i.LockID,
		&i.CreatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTournamentContests = `-- name: DeleteTournamentContests :exec
DELETE FROM tournament_contests WHERE round_id = $1
`

func (q *Queries) DeleteTournamentContests(ctx context.Context, roundID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTournamentContests, roundID)
	return err
}

const getTournamentById = `-- name: GetTournamentById :one
SELECT
    t.id,
    t.title,
    t.created_by,
    t.is_published,
    COALESCE(MAX(tr.round_number), 0)::int as rounds
FROM
    tournaments t
LEFT JOIN
    tournament_rounds tr
ON
    t.id = tr.tournament_id
WHERE
    t.id = $1
GROUP BY
    t.id
`

type GetTournamentByIdRow struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	CreatedBy   uuid.UUID `json:"created_by"`
	IsPublished bool      `json:"is_published"`
	Rounds      int32     `json:"rounds"`
}

func (q *Queries) GetTournamentById(ctx context.Context, id uuid.UUID) (GetTournamentByIdRow, error) {
	row := q.db.QueryRow(ctx, getTournamentById, id)
	var i GetTournamentByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedBy,
		&i.IsPublished,
		&i.Rounds,
	)
	return i, err
}

const getTournamentContests = `-- name: GetTournamentContests :many
SELECT contest_id FROM tournament_contests WHERE round_id = $1
`

func (q *Queries) GetTournamentContests(ctx context.Context, roundID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getTournamentContests, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var contest_id uuid.UUID
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentLatestRound = `-- name: GetTournamentLatestRound :one
SELECT 
    tr.id, tr.tournament_id, tr.round_number, tr.title, tr.lock_id, tr.created_by
FROM
    tournament_rounds tr
JOIN
    tournaments t ON tr.tournament_id = t.id
WHERE
    t.id = $1
ORDER BY
    tr.round_number DESC
LIMIT 1
`

type GetTournamentLatestRoundRow struct {
	ID           uuid.UUID  `json:"id"`
	TournamentID uuid.UUID  `json:"tournament_id"`
	RoundNumber  int32      `json:"round_number"`
	Title        string     `json:"title"`
	LockID       *uuid.UUID `json:"lock_id"`
	CreatedBy    uuid.UUID  `json:"created_by"`
}

func (q *Queries) GetTournamentLatestRound(ctx context.Context, id uuid.UUID) (GetTournamentLatestRoundRow, error) {
	row := q.db.QueryRow(ctx, getTournamentLatestRound, id)
	var i GetTournamentLatestRoundRow
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.RoundNumber,
		&i.Title,
		&i.LockID,
		&i.CreatedBy,
	)
	return i, err
}

const getTournamentLatestRoundEndTime = `-- name: GetTournamentLatestRoundEndTime :one
SELECT
    -- COALESCE handles the case where the latest round has no contests yet
    -- cast to timestamptz for type inference by sqlc
    COALESCE(MAX(c.end_time), '1970-01-01'::timestamptz)::timestamptz
FROM
    contests c
JOIN
    tournament_contests tc ON c.id = tc.contest_id
JOIN
    tournament_rounds tr ON tc.round_id = tr.id
WHERE
    tr.tournament_id = $1
AND
    -- This subquery finds the highest round number for the tournament
    tr.round_number = (
        SELECT MAX(round_number)
        FROM tournament_rounds
        WHERE tournament_id = $1
    )
`

func (q *Queries) GetTournamentLatestRoundEndTime(ctx context.Context, tournamentID uuid.UUID) (time.Time, error) {
	row := q.db.QueryRow(ctx, getTournamentLatestRoundEndTime, tournamentID)
	var column_1 time.Time
	err := row.Scan(&column_1)
	return column_1, err
}

const getTournamentRoundByNumber = `-- name: GetTournamentRoundByNumber :one
SELECT
    tr.id, tr.tournament_id,
    tr.round_number,
    tr.title,
    tr.lock_id,
    tr.created_by,

    -- lock fields
    l.access,
    l.timeout
FROM
    tournament_rounds tr
LEFT JOIN
    locks l
ON 
    tr.lock_id = l.id
WHERE
    tr.tournament_id = $1 AND tr.round_number = $2
`

type GetTournamentRoundByNumberParams struct {
	TournamentID uuid.UUID `json:"tournament_id"`
	RoundNumber  int32     `json:"round_number"`
}

type GetTournamentRoundByNumberRow struct {
	ID           uuid.UUID  `json:"id"`
	TournamentID uuid.UUID  `json:"tournament_id"`
	RoundNumber  int32      `json:"round_number"`
	Title        string     `json:"title"`
	LockID       *uuid.UUID `json:"lock_id"`
	CreatedBy    uuid.UUID  `json:"created_by"`
	Access       *string    `json:"access"`
	Timeout      *time.Time `json:"timeout"`
}

func (q *Queries) GetTournamentRoundByNumber(ctx context.Context, arg GetTournamentRoundByNumberParams) (GetTournamentRoundByNumberRow, error) {
	row := q.db.QueryRow(ctx, getTournamentRoundByNumber, arg.TournamentID, arg.RoundNumber)
	var i GetTournamentRoundByNumberRow
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.RoundNumber,
		&i.Title,
		&i.LockID,
		&i.CreatedBy,
		&i.Access,
		&i.Timeout,
	)
	return i, err
}

const getTournamentsByFilters = `-- name: GetTournamentsByFilters :many
SELECT
    t.id,
    t.title,
    t.created_by,
    t.is_published,
    COALESCE(MAX(tr.round_number), 0)::int as rounds
FROM
    tournaments t
LEFT JOIN
    tournament_rounds tr
ON
    t.id = tr.tournament_id
WHERE
    -- Optional filter by creator
    ($1::uuid IS NULL OR t.created_by = $1::uuid)
AND
    -- Optional filter by published status
    ($2::boolean IS NULL OR t.is_published = $2::boolean)
AND
    -- Title search with wildcards handled in SQL
    t.title ILIKE '%' || $3::text || '%'
ORDER BY
    t.created_at DESC
LIMIT
    $5
OFFSET
    $4
`

type GetTournamentsByFiltersParams struct {
	CreatedBy   *uuid.UUID `json:"created_by"`
	IsPublished *bool      `json:"is_published"`
	TitleSearch string     `json:"title_search"`
	Offset      int32      `json:"offset"`
	Limit       int32      `json:"limit"`
}

type GetTournamentsByFiltersRow struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	CreatedBy   uuid.UUID `json:"created_by"`
	IsPublished bool      `json:"is_published"`
	Rounds      int32     `json:"rounds"`
}

func (q *Queries) GetTournamentsByFilters(ctx context.Context, arg GetTournamentsByFiltersParams) ([]GetTournamentsByFiltersRow, error) {
	rows, err := q.db.Query(ctx, getTournamentsByFilters,
		arg.CreatedBy,
		arg.IsPublished,
		arg.TitleSearch,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentsByFiltersRow
	for rows.Next() {
		var i GetTournamentsByFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedBy,
			&i.IsPublished,
			&i.Rounds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
